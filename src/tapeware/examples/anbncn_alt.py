# SPDX-License-Identifier: CC0-1.0


def delta(state: str, symbol: str) -> tuple[str, str, str] | None:
    """
    Turing machine that recognises context-sensitive language aⁿbⁿcⁿ

    - It is not regular because it does not satisfy the pumping lemma for regular languages.
    - It is not context-free because it does not satisfy the pumping lemma for context-free languages.
    - It is context-sensitive because it can be generated by a context-sensitive grammar
      (e.g. S → aACD, A → aAC, A → ε, B → b, CD → BDc, CB → BC, D → ε).
    - Alternatively, it is context-sensitive because it can be recognised by a linear bounded automaton
      (e.g. mark 'a' as 'A', 'b' as 'B', 'c' as 'C', and check if all marked).

    Strategy: Use the aⁿbⁿ strategy twice
    - Phase 1: Match a's with b's (mark 'a' as 'A', 'b' as 'X')
    - Phase 2: Match X's with c's (remark 'X' as 'B', mark 'c' as 'C')
    """

    # Phase 1: Match a's with b's

    # State q₀: Initial state, look for first 'a'
    if state == "q₀":
        if symbol == "a":
            return ("q₁", "A", "R")  # Mark 'a' and look for 'b'
        elif symbol == "A":
            return ("q₀", "A", "R")  # Skip already marked 'a'
        elif symbol == "□":
            return ("qₐ", "□", "R")  # Empty input, accept
        else:
            return ("q₃", symbol, "R")  # No more unmarked 'a', check phase 1

    # State q₁: Marked 'a', looking for 'b'
    elif state == "q₁":
        if symbol in ["a", "X"]:
            return ("q₁", symbol, "R")  # Skip unmarked 'a' and marked 'X'
        elif symbol == "b":
            return ("q₂", "X", "L")  # Mark 'b' and go back
        else:
            return None  # No 'b' found, reject

    # State q₂: Go back left until we find 'A'
    elif state == "q₂":
        if symbol in ["a", "X"]:
            return ("q₂", symbol, "L")  # Keep going left
        elif symbol == "A":
            return ("q₀", "A", "R")  # Found marked 'a', continue phase 1
        else:
            return None  # Error, reject

    # State q₃: Check if phase 1 complete, transition to phase 2
    elif state == "q₃":
        if symbol == "X":
            return ("q₃", "X", "R")  # Skip marked 'b'
        elif symbol == "c":
            return ("q3b", "c", "L")  # Found c, go back for phase 2
        elif symbol == "□":
            return None  # Matched a's and b's but no c's, reject
        else:
            return None  # Error, reject

    # State q3b: Go back to beginning for phase 2
    elif state == "q3b":
        if symbol in ["A", "X"]:
            return ("q3b", symbol, "L")  # Keep going left
        elif symbol == "□":
            return ("q₄", "□", "R")  # Reached beginning, start phase 2
        else:
            return None  # Error

    # Phase 2: Match X's with c's

    # State q₄: Look for 'X'
    elif state == "q₄":
        if symbol == "A":
            return ("q₄", "A", "R")  # Skip marked 'a'
        elif symbol == "X":
            return ("q₅", "B", "R")  # Remark 'X' as 'B', look for 'c'
        elif symbol == "B":
            return ("q₄", "B", "R")  # Skip already remarked 'X'
        else:
            return ("q₇", symbol, "R")  # No more unmarked 'X', check phase 2

    # State q₅: Marked 'X' as 'B', looking for 'c'
    elif state == "q₅":
        if symbol in ["X", "C"]:
            return ("q₅", symbol, "R")  # Skip unmarked 'X' and marked 'C'
        elif symbol == "c":
            return ("q₆", "C", "L")  # Mark 'c' and go back
        else:
            return None  # No 'c' found, reject

    # State q₆: Go back left until we find 'B'
    elif state == "q₆":
        if symbol in ["X", "C"]:
            return ("q₆", symbol, "L")  # Keep going left
        elif symbol == "B":
            return ("q₄", "B", "R")  # Found marked 'X', continue phase 2
        else:
            return None  # Error, reject

    # State q₇: Check if all symbols are marked
    elif state == "q₇":
        if symbol == "C":
            return ("q₇", "C", "R")  # Skip marked 'c'
        elif symbol == "□":
            return ("qₐ", "□", "R")  # All marked, accept
        else:
            return None  # Found unmarked symbol, reject

    # Accept state
    elif state == "qₐ":
        return ("qₐ", symbol, "R")

    # Reject state
    elif state == "qᵣ":
        return ("qᵣ", symbol, "R")

    return None


test_cases = (
    ("", True),  # n=0
    ("abc", True),  # n=1
    ("aabbcc", True),  # n=2
    ("aaabbbccc", True),  # n=3
    ("aabbbc", False),  # unequal
    ("aaabbc", False),  # unequal
    ("abbc", False),  # unequal
    ("aabcc", False),  # unequal
)
